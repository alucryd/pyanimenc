#!/usr/bin/env python3

import argparse
import os
import re
import yaml
from pyanimenc import MatroskaOps, Encode

parser = argparse.ArgumentParser(description='Transcode files')
parser.add_argument('sources', nargs='*', help='Source files')
parser.add_argument('--settings', '-s', default='transcode.yml',
                    help='JSON settings file')
parser.add_argument('--preview', '-p', action='store_true',
                    help='Preview video output')
parser.add_argument('--test', '-t', action='store_true',
                    help='Track track settings')
args = parser.parse_args()

vid_types = ['V_MPEG4/ISO/AVC']
aud_types = {'A_AAC': 'aac', 'A_AC3': 'ac3', 'A_DTS': 'dts', 'A_FLAC': 'flac',
             'A_MP3': 'mp3', 'A_VORBIS': 'ogg', 'A_WAVPACK4': 'wv'}
sub_types = {'S_HDMV/PGS': 'sup', 'S_TEXT/ASS': 'ass', 'S_TEXT/SSA': 'ass',
             'S_TEXT/UTF8': 'srt', 'S_VOBSUB': 'sub'}

# Get source infos
for source in args.sources:
    print('\nProcessing "{}".\n'.format(source))
    sname, sext = os.path.splitext(source)
    sext = sext.strip('.')
    data = MatroskaOps(source).get_data()

# Read settings
    with open(args.settings, 'r') as f:
        data = f.read()
        settings = yaml.load(data)

    vid_track = settings['vid_track']
    aud_tracks = settings['aud_tracks']
    sub_tracks = settings.get('sub_tracks', [])
    vid_set = settings['video']
    aud_set = settings['audio']

# Make sure selected video track is video
    num = str(vid_track[0])
    vdata = data['track' + num]
    vid_type = vdata['codec']
    if args.test and vid_type not in vid_types:
        print('Track {} of "{}" is no audio. Got {}.\n'.format(num, source,
                                                               vid_type))
    else:
        vid_track.append(source)

# Make sure selected audio tracks are audio
    for track in aud_tracks:
        num = str(track[0])
        adata = data['track' + num]
        aud_type = adata['codec']
        aud_lang = adata.get('lang', '')
        if args.test:
            if aud_type not in aud_types:
                print(('Track {} of "{}" is no audio. '
                       'Got {}.\n').format(num, source, aud_type))
            elif aud_lang and aud_lang != track[1]:
                print(('Track {} of "{}" is {} instead of '
                       '{}.\n').format(num, source, aud_lang, track[1]))
        else:
            aud_ext = aud_types[aud_type]
            track.append(aud_ext)

# Make sure selected sub tracks are subtitles
    for track in sub_tracks:
        num = str(track[0])
        sdata = data['track' + num]
        sub_type = sdata['codec']
        sub_lang = sdata.get('lang', '')
        if args.test:
            if sub_type not in sub_types:
                print(('Track {} of "{}" is no subtitles. '
                       'Got {}.\n').format(num, source, sub_type))
            elif sub_lang and sub_lang != track[1]:
                print(('Track {} of "{}" is {} instead of '
                       '{}.\n').format(num, source, sub_lang, track[1]))
        else:
            sub_ext = sub_types[sub_type]
            track.append(sub_ext)

    if not args.test:

# Video encoding
        if vid_set['enc']:
            vpyscript = sname + '.vpy'
            bit_depth = vid_set.get('bit_depth', 10)
            crf = vid_set.get('crf', 15)
            preset = vid_set.get('preset', 'slow')
            tune = vid_set.get('tune', 'animation')
            fpsnum = vid_set.get('fpsnum', 24000)
            fpsden = vid_set.get('fpsden', 1001)
            trim = vid_set.get('trim', [])
            crop = vid_set.get('crop', [])
            resize = vid_set.get('resize', [])
            deband = vid_set.get('deband', '')

# Create VapourSynth script if none exists
            if not os.path.isfile(vpyscript):
                print('Creating VapourSynth script.\n')
                with open(vpyscript, 'w') as f:
                    f.write((
                        'from pyanimenc import Encode\n'
                        'Encode("{}").vpy(fpsnum={}, fpsden={}, trim={}, '
                        'crop={}, resize={}, deband="{}", bit_depth={})'
                    ).format(source, str(fpsnum), str(fpsden), str(trim),
                             str(crop), str(resize), str(deband),
                             str(bit_depth)))

# Encode video
            print('Encoding video.\n')
            Encode(source).video(crf, bit_depth, preset, tune, args.preview)
            vid_track[0] = 0
            vid_track[2] = sname + '.mp4'

# Extract tracks
        print('\nExtracting tracks.\n')
        tracks = aud_tracks + sub_tracks
        for track in tracks:
            track[2] = '{}_{}.{}'.format(sname, track[0], track[2])
        MatroskaOps(source).extract(tracks)

# Audio encoding
        if aud_set['enc']:
            quality = aud_set.get('quality', 4)
            container = aud_set.get('container', 'aac')

# Encode audio if not AAC, MP3 or OGG
            for track in aud_tracks:
                if not re.search('\.(aac|mp3|ogg)$', track[2]):
                    print('\nEncoding audio.\n')
                    Encode(track[2]).audio(quality, container)
                    track[2] = '.'.join((os.path.splitext(track[2])[0],
                                                          container))

# Mux files
        print('\nMuxing tracks.\n')
        MatroskaOps(source).merge(vid_track, aud_tracks, sub_tracks,
                                  data['uid'])

# vim: ts=4 sw=4 et:
