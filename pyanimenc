#!/usr/bin/env python3

import os
import re
import subprocess
import yaml
from concurrent.futures import ThreadPoolExecutor
from gi.repository import Gtk,GdkPixbuf
from pyanimenc import Encode,MatroskaOps

class Handler:
    def __init__(self):
        self.queue = ThreadPoolExecutor(max_workers=1)
        self.tools = ThreadPoolExecutor(max_workers=2)

    def on_vs_creator_clicked(self, button):
        self.tools.submit(self.vs_creator)

    def vs_creator(self):
        cmd = '/usr/lib/python3.4/site-packages/pyanimenc/vs-script-creator.py'
        subprocess.call(cmd)

    def on_chap_editor_clicked(self, button):
        self.tools.submit(self.chapter_editor)

    def chapter_editor(self):
        cmd = '/usr/lib/python3.4/site-packages/pyanimenc/chapter-editor.py'
        subprocess.call(cmd)

    def on_vsource_file_set(self, button):
        vstart_button.set_sensitive(True)

    def on_asource_file_set(self, button):
        astart_button.set_sensitive(True)

    def on_vstart_clicked(self, button):
        x = venc_cbtext.get_active_text()
        s = vsource_fcbutton.get_filename()
        wd = os.path.dirname(s)
        if not os.path.isdir(wd + '/out'):
            os.mkdir(wd + '/out')
        d = wd + '/out/' + os.path.basename(os.path.splitext(s)[0])
        if x == 'x264':
            dp = int(x264_depth_cbtext.get_active_text())
            q = x264_quality_spin.get_value_as_int()
            p = x264_preset_cbtext.get_active_text()
            if p == 'none':
                p = ''
            t = x264_tune_cbtext.get_active_text()
            if t == 'none':
                t = ''
            c = x264_container_cbtext.get_active_text()
            self.queue.submit(self.x264, s, d, dp, q, p, t, c)
        elif x == 'x265':
            dp = int(x265_depth_cbtext.get_active_text())
            q = x265_quality_spin.get_value_as_int()
            p = x265_preset_cbtext.get_active_text()
            if p == 'none':
                p = ''
            t = x265_tune_cbtext.get_active_text()
            if t == 'none':
                t = ''
            c = x265_container_cbtext.get_active_text()
            self.queue.submit(self.x265, s, d, dp, q, p, t, c)

    def on_astart_clicked(self, button):
        x = aenc_cbtext.get_active_text()
        s = asource_fcbutton.get_filename()
        wd = os.path.dirname(s)
        if not os.path.isdir(f + '/out'):
            os.mkdir(wd + '/out')
        d = wd + '/out/' + os.path.basename(os.path.splitext(s)[0])
        if x == 'fdkaac':
            m = fdkaac_mode_cbtext.get_active_text()
            b = fdkaac_bitrate_spin.get_value_as_int()
            q = fdkaac_quality_spin.get_value_as_int()
            c = fdkaac_container_cbtext.get_active_text()
            self.queue.submit(self.fdkaac, s, d, m, b, q, c)
        elif x == 'lame':
            m = lame_mode_cbtext.get_active_text()
            b = lame_bitrate_spin.get_value_as_int()
            q = lame_quality_spin.get_value_as_int()
            self.queue.submit(self.lame, s, d, m, b, q)

    def on_batch_source_set(self, button):
        wd = button.get_filename()
        self.sources = []
        self.data = []
        self.tracks = []

        # Keep videos only
        for f in os.listdir(wd):
            for cont in vcontainers:
                if re.search('\.' + cont + '$', f):
                    f = wd + '/' + f
                    self.sources.append(f)

        # Get source infos
        for i in range(len(self.sources)):
            s = self.sources[i]
            data = MatroskaOps(s).get_data()
            self.data.append(data)

        # Make sure tracks are identical across files
        # Dirty way of modifying a GtkMessageDialog primary message.
        error = track_mismatch_dialog.get_children()[0].get_children()[0]
        error = error.get_children()[0].get_children()[0]
        for i in range(1, len(self.data)):
            tracks_orig = self.data[0]
            tracks = self.data[i]
            if len(tracks) != len(tracks_orig):
                t = ('{} ({} tracks) and {} ({} tracks) differ from each '
                     'other. Please make sure all files share the same '
                     'layout.'
                    ).format(self.sources[0], str(len(tracks_orig)),
                             self.sources[i], str(len(tracks)))
                error.set_text(t)
                track_mismatch_dialog.run()
            # -1 because there is a 'uid' entry
            for j in range(len(tracks) - 1):
                k = 'track' + str(j)
                codec_orig = tracks_orig[k]['codec']
                lang_orig = tracks_orig[k].get('lang', '')
                channels_orig = tracks_orig[k].get('channels', '')
                codec = tracks[k]['codec']
                lang = tracks[k].get('lang', '')
                channels = tracks[k].get('channels', '')
                if codec != codec_orig:
                    t = ('{} (track {}: {}) and {} (track {}: {}) have '
                         'different codecs. Please make sure all files '
                         'share the same layout.'
                        ).format(self.sources[0], str(j), codec_orig,
                                 self.sources[i], str(j), codec)
                    error.set_text(t)
                    track_mismatch_dialog.run()
                elif lang != lang_orig:
                    t = ('{} (track {}: {}) and {} (track {}: {}) have '
                         'different languages. Please make sure all files '
                         'share the same layout.'
                        ).format(self.sources[0], str(j), lang_orig,
                                 self.sources[i], str(j), lang)
                    error.set_text(t)
                    track_mismatch_dialog.run()
                elif channels != channels_orig:
                    t = ('{} (track {}: {}) and {} (track {}: {}) have '
                         'different channels. Please make sure all files '
                         'share the same layout.'
                        ).format(self.sources[0], str(j), channels_orig,
                                 self.sources[i], str(j), channels)
                    error.set_text(t)
                    track_mismatch_dialog.run()
        self.update_tracks()

    def update_tracks(self):
        # A new builder instance needs to be created for each entry,
        # therefore put the template on its own to avoid loading a large
        # file every time
        for track in batch_tracks_vbox.get_children():
            batch_tracks_vbox.remove(track)

        # -1 because there is a 'uid' entry
        tracks = self.data[0]
        for i in range(len(tracks) - 1):
            builder = Gtk.Builder()
            builder.add_from_file('/home/alucryd/pyanimenc/track.glade')
            grid = builder.get_object('grid')
            batch_tracks_vbox.pack_start(grid, False, False, 0)
            enable_check = builder.get_object('enable-check')
            enable_check.connect('toggled', handler.on_track_enable_toggled, i)
            codec_entry = builder.get_object('codec-entry')
            name_entry = builder.get_object('name-entry')
            name_entry.connect('changed', handler.on_track_name_changed, i)
            lang_entry = builder.get_object('lang-entry')
            lang_entry.connect('changed', handler.on_track_lang_changed, i)
            encode_check = builder.get_object('encode-check')
            encode_check.connect('toggled', handler.on_track_encode_toggled, i)

            track = tracks['track' + str(i)]
            codec = track['codec']
            name = track.get('name', '')
            lang = track.get('lang', 'und')
            if codec in vtypes:
                type = 'video'
                enable_check.set_label('Video')
                enable_check.set_sensitive(False)
                codec = vtypes[codec]
            elif codec in atypes:
                type = 'audio'
                enable_check.set_label('Audio')
                channels = track['channels']
                if channels == '2':
                    channels = '2.0'
                elif channels == '6':
                    channels = '5.1'
                elif channels == '8':
                    channels = '7.1'
                codec = atypes[codec]
            elif codec in stypes:
                type = 'subtitle'
                enable_check.set_label('Subtitle')
                encode_check.set_sensitive(False)
                codec = stypes[codec]

            self.tracks.append([type, codec, name, lang, True, True, i])
            if type == 'audio':
                codec = codec + ' ' + channels
            if type == 'subtitle':
                # Put this here to avoid out of range index.
                encode_check.set_active(False)
            codec_entry.set_text(codec)
            name_entry.set_text(name)
            lang_entry.set_text(lang)

        window.show()

    def on_track_mismatch_ok_clicked(self, button):
        track_mismatch_dialog.hide()

    def on_batch_start_clicked(self, button):
        wd = batch_source_fcbutton.get_filename()
        if not os.path.isdir(wd + '/out'):
            os.mkdir(wd + '/out')

        for i in range(len(self.sources)):
            vtrack = []
            atracks = []
            stracks = []
            s = self.sources[i]
            uid = self.data[i]['uid']
            for track in self.tracks:
                # [[id, filename, extension, name, language, transcode?]...]
                j = track[6]
                f, e = os.path.splitext(os.path.basename(s))
                e = e.strip('.')
                n = track[2]
                l = track[3]
                t = track[5]
                if track[0] == 'video' and track[4]:
                    if track[5]:
                        f = wd + '/out/' + f
                        e = track[1]
                    else:
                        f = wd + '/' + f
                    vtrack = [j, f, e, n, l, t]
                if track[0] == 'audio' and track[4]:
                    if track[5]:
                        f = wd + '/out/' + f + '_' + str(j)
                        e = track[1]
                    else:
                        f = wd + '/' + f
                    atracks.append([j, f, e, n, l, t])
                if track[0] == 'subtitle' and track[4]:
                    f = wd + '/' + f
                    stracks.append([j, f, e, n, l, t])

            if vtrack[5]:
                vtrack[0] = 0
                # Create VapourSynth script
                c = []
                d = ''
                r = []

                fn = vpy_fpsnum_spin.get_value_as_int()
                fd = vpy_fpsden_spin.get_value_as_int()
                if vpy_crop_check.get_active():
                    cl = vpy_lcrop_spin.get_value_as_int()
                    cr = vpy_rcrop_spin.get_value_as_int()
                    ct = vpy_tcrop_spin.get_value_as_int()
                    cb = vpy_bcrop_spin.get_value_as_int()
                    c = [cl, cr, ct, cb]
                if vpy_deband_check.get_active():
                    pr = vpy_deband_preset_cbtext.get_active_text()
                    ch = vpy_deband_channel_cbtext.get_active_text()
                    ng = vpy_deband_nograin_check.get_active()
                    d = pr
                    if ch in ['luma', 'chroma']:
                        d = d + '/' + ch
                    if ng:
                        d = d + '/nograin'
                if vpy_resize_check.get_active():
                    rw = vpy_wresize_spin.get_value_as_int()
                    rh = vpy_hresize_spin.get_value_as_int()
                    rf = vpy_resize_filter_cbtext.get_active_text()
                    r = [rw, rh, rf]

                self.queue.submit(self.vpy, s, fn, fd, c, d, r)

                # Encode video
                x = batch_venc_cbtext.get_active_text()
                if x == 'x264':
                    dp = int(x264_depth_cbtext.get_active_text())
                    q = x264_quality_spin.get_value_as_int()
                    p = x264_preset_cbtext.get_active_text()
                    if p == 'none':
                        p = ''
                    t = x264_tune_cbtext.get_active_text()
                    if t == 'none':
                        t = ''
                    c = x264_container_cbtext.get_active_text()
                    vtrack[2] = c

                    self.queue.submit(self.x264, s, vtrack[1], dp, q, p, t, c)
                if x == 'x265':
                    dp = int(x265_depth_cbtext.get_active_text())
                    q = x265_quality_spin.get_value_as_int()
                    p = x265_preset_cbtext.get_active_text()
                    if p == 'none':
                        p = ''
                    t = x265_tune_cbtext.get_active_text()
                    if t == 'none':
                        t = ''
                    c = x265_container_cbtext.get_active_text()
                    vtrack[2] = c

                    self.queue.submit(self.x265, s, vtrack[1], dp, q, p, t, c)

            # Extract audio
            tracks = []
            for track in atracks:
                if track[5]:
                    tracks.append(track)

            self.queue.submit(self.extract, s, tracks)

            # Encode audio
            for track in atracks:
                if track[5]:
                    x = batch_aenc_cbtext.get_active_text()
                    a = track[1] + '.' + track[2]
                    if x == 'fdkaac':
                        m = fdkaac_mode_cbtext.get_active_text()
                        b = fdkaac_bitrate_spin.get_value_as_int()
                        q = fdkaac_quality_spin.get_value_as_int()
                        c = fdkaac_container_cbtext.get_active_text()

                        self.queue.submit(self.fdkaac, a, track[1], m, b, q, c)

                    elif x == 'lame':
                        m = lame_mode_cbtext.get_active_text()
                        b = lame_bitrate_spin.get_value_as_int()
                        q = lame_quality_spin.get_value_as_int()

                        self.queue.submit(self.lame, a, track[1], m, b, q)

            # Merge tracks
            o = wd + '/out/' + os.path.basename(s)
            self.queue.submit(self.merge, s, o, vtrack, atracks, stracks, uid)

            # Clean up
            self.queue.submit(self.clean, wd)

    def extract(self, source, tracks):
        cmd = MatroskaOps(source).extract(tracks)
        print(cmd)
        subprocess.call(cmd, shell=True)
        #with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stdout.readline()
        #        log_buffer.insert(log_buffer.get_end_iter(), line)
        #        if line:
        #            print(line)
        #        else:
        #            break

    def merge(self, source, dest, vtrack, atracks, stracks, uid):
        # Put that here until I figure out why it screws the extract step when
        # done above.
        for track in atracks:
            if track[5]:
                track[0] = 0
                x = batch_aenc_cbtext.get_active_text()
                if x == 'fdkaac':
                    c = fdkaac_container_cbtext.get_active_text()
                    track[2] = c
                elif x == 'lame':
                    track[2] = 'mp3'

        cmd = MatroskaOps(source).merge(dest, vtrack, atracks, stracks, uid)
        print(cmd)
        subprocess.call(cmd, shell=True)
        #with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stdout.readline()
        #        log_buffer.insert(log_buffer.get_end_iter(), line)
        #        if line:
        #            print(line)
        #        else:
        #            break

    def clean(self, directory):
        for f in os.listdir(directory):
            if re.search('\.vpy$', f) or re.search('\.ffindex$', f):
                os.remove(directory + '/' + f)
        for f in os.listdir(directory + '/out/'):
            if not re.search('\.mkv$', f):
                os.remove(directory + '/out/' + f)

    def vpy(self, source, fpsnum, fpsden, crop, deband, resize):
        v = ''
        s = ''
        c = ''
        d = ''
        r = ''

        v = 'import vapoursynth as vs\n'
        v = v + 'core = vs.get_core()\n'
        s = 'clip = core.ffms2.Source("{}", fpsnum={}, fpsden={})\n'
        s = s.format(source, fpsnum, fpsden)
        if crop:
            c = 'clip = core.std.CropRel(clip, {}, {}, {}, {})\n'
            c = c.format(crop[0], crop[1], crop[2], crop[3])
        if deband:
            d = 'clip = core.f3kdb.Deband(clip, preset="{}", '
            d = d + 'output_depth=16)\n'
            d = d.format(deband)
        if resize:
            r = 'clip = core.resize.{}(clip, {}, {})\n'
            r = r.format(resize[2].capitalize(), resize[0], resize[1])
        v = v + s + c + d + r
        v = v + 'clip.set_output()'

        vpy = re.sub('[^.]*$', 'vpy', source)
        with open(vpy, 'w') as f:
            f.write(v)

    def x264(self, source, dest, depth, quality, preset, tune, container):
        #cmd = Encode(source).info()
        #with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stdout.readline()
        #        if line:
        #            # Get the frame total
        #            if 'Frames' in line:
        #                dur = line.split(' ')[1]
        #                dur = int(dur)
        #        else:
        #            break

        cmd = Encode(source).x264(dest, depth, quality, preset, tune,
                                  container)
        print(cmd)
        subprocess.call(cmd, shell=True)
        #with subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stderr.readline()
        #        log_buffer.insert(log_buffer.get_end_iter(), line)
        #        if line:
        #            # Get the current frame
        #            if re.match('^[0-9]+ ', line):
        #                pos = line.split(' ')[0]
        #                pos = int(pos)
        #                progress = round(pos / dur, 2)
        #                status_pbar.set_fraction(progress)
        #        else:
        #            status_pbar.set_fraction(1)
        #            break

    def x265(self, source, dest, depth, quality, preset, tune, container):
        cmd = Encode(source).x265(dest, depth, quality, preset, tune,
                                  container)
        print(cmd)
        subprocess.call(cmd, shell=True)

    def fdkaac(self, source, dest, mode, bitrate, quality, container):
        cmd = Encode(source).fdkaac(dest, mode, bitrate, quality, container)
        print(cmd)
        subprocess.call(cmd, shell=True)
        #with subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stderr.readline()
        #        log_buffer.insert(log_buffer.get_end_iter(), line)
        #        if line:
        #            # Get the clip duration
        #            if 'Duration' in line:
        #                dur = re.findall('[0-9]{2}:[0-9]{2}:[0-9]{2}', line)[0]
        #                h, m, s = dur.split(':')
        #                dur = int(h) * 3600 + int(m) * 60 + int(s)
        #            # Get the current timestamp
        #            if re.match('[0-9]{2}:[0-9]{2}\.[0-9]{3}', line):
        #                pos = re.findall('^[0-9]{2}:[0-9]{2}', line)[0]
        #                m, s = pos.split(':')
        #                pos = int(m) * 60 + int(s)
        #                progress = round(pos / dur, 2)
        #                status_pbar.set_fraction(progress)
        #        else:
        #            status_pbar.set_fraction(1)
        #            break

    def lame(self, source, dest, mode, bitrate, quality):
        cmd = Encode(source).lame(dest, mode, bitrate, quality)
        print(cmd)
        subprocess.call(cmd, shell=True)

    def on_stop_clicked(self, button):
        self.queue.shutdown()

    def on_batch_vpy_clicked(self, button):
        vpy_dialog.run()

    def on_vpy_crop_toggled(self, check):
        state = check.get_active()
        vpy_lcrop_spin.set_sensitive(state)
        vpy_rcrop_spin.set_sensitive(state)
        vpy_tcrop_spin.set_sensitive(state)
        vpy_bcrop_spin.set_sensitive(state)

    def on_vpy_resize_toggled(self, check):
        state = check.get_active()
        vpy_wresize_spin.set_sensitive(state)
        vpy_hresize_spin.set_sensitive(state)
        vpy_resize_filter_cbtext.set_sensitive(state)

    def on_vpy_deband_toggled(self, check):
        state = check.get_active()
        vpy_deband_preset_cbtext.set_sensitive(state)
        vpy_deband_channel_cbtext.set_sensitive(state)
        vpy_deband_nograin_check.set_sensitive(state)

    def on_vpy_ok_clicked(self, button):
        vpy_dialog.hide()

    def on_track_name_changed(self, entry, i):
        self.tracks[i][2] = entry.get_text()

    def on_track_lang_changed(self, entry, i):
        self.tracks[i][3] = entry.get_text()

    def on_track_enable_toggled(self, check, i):
        self.tracks[i][4] = check.get_active()

    def on_track_encode_toggled(self, check, i):
        self.tracks[i][5] = check.get_active()

    def on_vsettings_clicked(self, button):
        x = venc_cbtext.get_active_text()
        if x in ['x264', 'x264-10bit']:
            x264_dialog.run()
        elif x in ['x265', 'x265-10bit']:
            x265_dialog.run()

    def on_batch_vsettings_clicked(self, button):
        x = batch_venc_cbtext.get_active_text()
        if x in ['x264', 'x264-10bit']:
            x264_dialog.run()
        if x in ['x265', 'x265-10bit']:
            x265_dialog.run()

    def on_x264_ok_clicked(self, button):
        x264_dialog.hide()

    def on_x265_ok_clicked(self, button):
        x265_dialog.hide()

    def on_asettings_clicked(self, button):
        x = aenc_cbtext.get_active_text()
        if x == 'fdkaac':
            fdkaac_dialog.run()
        elif x == 'lame':
            lame_dialog.run()

    def on_batch_asettings_clicked(self, button):
        x = batch_aenc_cbtext.get_active_text()
        if x == 'fdkaac':
            fdkaac_dialog.run()
        elif x == 'lame':
            lame_dialog.run()

    def on_fdkaac_mode_changed(self, combo):
        m = combo.get_active_text()
        if m == 'CBR':
            fdkaac_bitrate_spin.set_sensitive(True)
            fdkaac_quality_spin.set_sensitive(False)
        elif m == 'VBR':
            fdkaac_bitrate_spin.set_sensitive(False)
            fdkaac_quality_spin.set_sensitive(True)

    def on_fdkaac_ok_clicked(self, button):
        fdkaac_dialog.hide()

    def on_lame_mode_changed(self, combo):
        m = combo.get_active_text()
        if m == 'CBR' or m == 'ABR':
            lame_bitrate_spin.set_sensitive(True)
            lame_quality_spin.set_sensitive(False)
        elif m == 'VBR':
            lame_bitrate_spin.set_sensitive(False)
            lame_quality_spin.set_sensitive(True)

    def on_lame_ok_clicked(self, button):
        lame_dialog.hide()

    def on_log_clear_clicked(self, button):
        log_buffer.set_text('')

    def on_window_delete_event(self, *args):
        Gtk.main_quit(*args)

# Some constants and variables
vencs = ['x264', 'x264-10bit', 'x265', 'x265-10bit']
vcontainers = ['avi', 'mkv', 'mp4', 'ogm']
vtypes = {'V_MPEG4/ISO/AVC': 'h264'}
aencs = ['fdkaac', 'lame']
acontainers= ['aac', 'ac3', 'dts', 'flac', 'mka', 'mp3', 'mp4', 'thd', 'ogg',
              'wv']
atypes = {'A_AAC': 'aac', 'A_AC3': 'ac3', 'A_DTS': 'dts', 'A_FLAC': 'flac',
          'A_MP3': 'mp3', 'A_TRUEHD': 'thd', 'A_VORBIS': 'ogg',
          'A_WAVPACK4': 'wv'}
stypes = {'S_HDMV/PGS': 'sup', 'S_TEXT/ASS': 'ass', 'S_TEXT/SSA': 'ass',
          'S_TEXT/UTF8': 'srt', 'S_VOBSUB': 'sub'}

# Build the GUI
builder = Gtk.Builder()
builder.add_from_file('/usr/share/pyanimenc/pyanimenc.glade')

window = builder.get_object('window')
vsource_fcbutton = builder.get_object('vsource-fcbutton')
vstart_button = builder.get_object('vstart-button')
venc_cbtext = builder.get_object('venc-cbtext')
vsettings_button = builder.get_object('vsettings-button')
asource_fcbutton = builder.get_object('asource-fcbutton')
astart_button = builder.get_object('astart-button')
aenc_cbtext = builder.get_object('aenc-cbtext')
asettings_button = builder.get_object('asettings-button')
status_pbar = builder.get_object('status-pbar')
log_buffer = builder.get_object('log-buffer')

batch_source_fcbutton = builder.get_object('batch_source-fcbutton')
batch_venc_cbtext = builder.get_object('batch_venc-cbtext')
batch_vsettings_button = builder.get_object('batch_vsettings-button')
batch_aenc_cbtext = builder.get_object('batch_aenc-cbtext')
batch_asettings_button = builder.get_object('batch_asettings-button')
batch_tracks_vbox = builder.get_object('batch_tracks-vbox')
track_mismatch_dialog = builder.get_object('track_mismatch-dialog')
vpy_dialog = builder.get_object('vpy-dialog')
vpy_crop_check = builder.get_object('vpy_crop-check')
vpy_lcrop_spin = builder.get_object('vpy_lcrop-spin')
vpy_rcrop_spin = builder.get_object('vpy_rcrop-spin')
vpy_tcrop_spin = builder.get_object('vpy_tcrop-spin')
vpy_bcrop_spin = builder.get_object('vpy_bcrop-spin')
vpy_resize_check = builder.get_object('vpy_resize-check')
vpy_wresize_spin = builder.get_object('vpy_wresize-spin')
vpy_hresize_spin = builder.get_object('vpy_hresize-spin')
vpy_resize_filter_cbtext = builder.get_object('vpy_resize_filter-cbtext')
vpy_deband_check = builder.get_object('vpy_deband-check')
vpy_deband_preset_cbtext = builder.get_object('vpy_deband_preset-cbtext')
vpy_deband_channel_cbtext = builder.get_object('vpy_deband_channel-cbtext')
vpy_deband_nograin_check = builder.get_object('vpy_deband_nograin-check')
vpy_fpsnum_spin = builder.get_object('vpy_fpsnum-spin')
vpy_fpsden_spin = builder.get_object('vpy_fpsden-spin')

handler = Handler()
builder.connect_signals(handler)

# Populate the encoder combos
x264_found = False
x264_depth = []
x265_found = False
x265_depth = []
for enc in vencs:
    if os.path.isfile('/usr/bin/' + enc):
        if enc == 'x264':
            x264_depth.append('8')
            x264_found = True
        elif enc == 'x264-10bit':
            x264_depth.append('10')
            x264_found = True
        elif enc == 'x265':
            x265_depth.append('8')
            x265_found = True
        elif enc == 'x265-10bit':
            x265_depth.append('10')
            x265_found = True
        else:
            venc_cbtext.append_text(enc)
            batch_venc_cbtext.append_text(enc)
        print('Found ' + enc + '.')
    else:
        vencs.pop(vencs.index(enc))
if x264_found:
    venc_cbtext.append_text('x264')
    batch_venc_cbtext.append_text('x264')
if x265_found:
    venc_cbtext.append_text('x265')
    batch_venc_cbtext.append_text('x265')

for enc in aencs:
    if os.path.isfile('/usr/bin/' + enc):
        aenc_cbtext.append_text(enc)
        batch_aenc_cbtext.append_text(enc)
        print('Found ' + enc + '.')
    else:
        aencs.pop(aencs.index(enc))

if vencs:
    venc_cbtext.set_active(0)
    vsettings_button.set_sensitive(True)
    batch_venc_cbtext.set_active(0)
    batch_vsettings_button.set_sensitive(True)
if aencs:
    aenc_cbtext.set_active(0)
    asettings_button.set_sensitive(True)
    batch_aenc_cbtext.set_active(0)
    batch_asettings_button.set_sensitive(True)

# GUI for encoder settings
if x264_found:
    x264_dialog = builder.get_object('x264-dialog')
    x264_depth_cbtext = builder.get_object('x264_depth-cbtext')
    for dp in x264_depth:
        x264_depth_cbtext.append_text(dp)
    x264_depth_cbtext.set_active(0)
    x264_quality_spin = builder.get_object('x264_quality-spin')
    x264_preset_cbtext = builder.get_object('x264_preset-cbtext')
    x264_tune_cbtext = builder.get_object('x264_tune-cbtext')
    x264_container_cbtext = builder.get_object('x264_container-cbtext')
if x265_found:
    x265_dialog = builder.get_object('x265-dialog')
    x265_depth_cbtext = builder.get_object('x265_depth-cbtext')
    for dp in x265_depth:
        x265_depth_cbtext.append_text(dp)
    x265_depth_cbtext.set_active(0)
    x265_quality_spin = builder.get_object('x265_quality-spin')
    x265_preset_cbtext = builder.get_object('x265_preset-cbtext')
    x265_tune_cbtext = builder.get_object('x265_tune-cbtext')
    x265_container_cbtext = builder.get_object('x265_container-cbtext')

for enc in aencs:
    if enc == 'fdkaac':
        fdkaac_dialog = builder.get_object('fdkaac-dialog')
        fdkaac_mode_cbtext = builder.get_object('fdkaac_mode-cbtext')
        fdkaac_bitrate_spin = builder.get_object('fdkaac_bitrate-spin')
        fdkaac_quality_spin = builder.get_object('fdkaac_quality-spin')
        fdkaac_container_cbtext = builder.get_object('fdkaac_container-cbtext')
    elif enc == 'lame':
        lame_dialog = builder.get_object('lame-dialog')
        lame_mode_cbtext = builder.get_object('lame_mode-cbtext')
        lame_bitrate_spin = builder.get_object('lame_bitrate-spin')
        lame_quality_spin = builder.get_object('lame_quality-spin')

window.show_all()

Gtk.main()

# vim: ts=4 sw=4 et:
