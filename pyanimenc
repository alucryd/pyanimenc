#!/usr/bin/env python3

import os
import re
import subprocess
import yaml
from concurrent.futures import ThreadPoolExecutor
from gi.repository import Gtk,GdkPixbuf
from pyanimenc import Encode,MatroskaOps

class Handler:
    def __init__(self):
        self.vsource = ''
        self.venc = ''
        self.vdepth = 8
        self.vquality = 0
        self.vcontainer = ''
        self.vpreset = ''
        self.vtune = ''
        self.asource = ''
        self.aenc = ''
        self.aquality = 0
        self.acontainer = ''
        self.trim = []
        self.crop = []
        self.resize = []
        self.deband = ''
        self.fpsnum = 24000
        self.fpsden = 1001
        self.queue = ThreadPoolExecutor(max_workers=1)
        self.tools = ThreadPoolExecutor(max_workers=2)

    def on_vs_creator_clicked(self, button):
        self.tools.submit(self.vs_creator)

    def vs_creator(self):
        cmd = '/usr/lib/python3.4/site-packages/pyanimenc/vs-script-creator.py'
        subprocess.call(cmd)

    def on_chap_editor_clicked(self, button):
        self.tools.submit(self.chapter_editor)

    def chapter_editor(self):
        cmd = '/usr/lib/python3.4/site-packages/pyanimenc/chapter-editor.py'
        subprocess.call(cmd)

    def on_vsource_file_set(self, button):
        self.vsource = button.get_filename()
        self.folder = os.path.dirname(self.vsource)
        os.chdir(self.folder)
        status_pbar.set_fraction(0)

    def on_asource_file_set(self, button):
        self.asource = button.get_filename()
        self.folder = os.path.dirname(self.asource)
        os.chdir(self.folder)
        status_pbar.set_fraction(0)

    def on_vstart_clicked(self, button):
        if not os.path.isdir('out'):
            os.mkdir(self.folder + '/out')
        dest = 'out/' + os.path.basename(os.path.splitext(self.vsource)[0])
        if self.venc == 'x264' or self.venc == 'x264-10bit':
            self.queue.submit(self.x264, self.vsource, dest)

    def on_astart_clicked(self, button):
        if not os.path.isdir('out'):
            os.mkdir(self.folder + '/out')
        dest = 'out/' + os.path.basename(os.path.splitext(self.asource)[0])
        if self.aenc == 'fdkaac':
            self.queue.submit(self.fdkaac, self.asource, dest)
        elif self.aenc == 'lame':
            m = lame_mode_cbtext.get_active_text()
            b = lame_bitrate_spin.get_value_as_int()
            q = lame_quality_spin.get_value_as_int()
            self.queue.submit(self.lame, self.asource, dest, m, b, q)

    def on_batch_source_set(self, button):
        self.folder = button.get_filename()
        os.chdir(self.folder)
        self.sources = []
        self.data = []
        self.tracks = []

        # Keep videos only
        for f in os.listdir():
            for cont in vcontainers:
                if re.search('\.' + cont + '$', f):
                    self.sources.append(f)

        # Get source infos
        for i in range(len(self.sources)):
            s = self.sources[i]
            data = MatroskaOps(s).get_data()
            self.data.append(data)

        # Make sure tracks are identical across files
        # Dirty way of modifying a GtkMessageDialog primary message.
        error = track_mismatch_dialog.get_children()[0].get_children()[0]
        error = error.get_children()[0].get_children()[0]
        for i in range(1, len(self.data)):
            tracks_orig = self.data[0]
            tracks = self.data[i]
            if len(tracks) != len(tracks_orig):
                t = ('{} ({} tracks) and {} ({} tracks) differ from each '
                     'other. Please make sure all files share the same '
                     'layout.'
                    ).format(self.sources[0], str(len(tracks_orig)),
                             self.sources[i], str(len(tracks)))
                error.set_text(t)
                track_mismatch_dialog.run()
            # -1 because there is a 'uid' entry
            for j in range(len(tracks) - 1):
                k = 'track' + str(j)
                codec_orig = tracks_orig[k]['codec']
                lang_orig = tracks_orig[k].get('lang', '')
                channels_orig = tracks_orig[k].get('channels', '')
                codec = tracks[k]['codec']
                lang = tracks[k].get('lang', '')
                channels = tracks[k].get('channels', '')
                if codec != codec_orig:
                    t = ('{} (track {}: {}) and {} (track {}: {}) have '
                         'different codecs. Please make sure all files '
                         'share the same layout.'
                        ).format(self.sources[0], str(j), codec_orig,
                                 self.sources[i], str(j), codec)
                    error.set_text(t)
                    track_mismatch_dialog.run()
                elif lang != lang_orig:
                    t = ('{} (track {}: {}) and {} (track {}: {}) have '
                         'different languages. Please make sure all files '
                         'share the same layout.'
                        ).format(self.sources[0], str(j), lang_orig,
                                 self.sources[i], str(j), lang)
                    error.set_text(t)
                    track_mismatch_dialog.run()
                elif channels != channels_orig:
                    t = ('{} (track {}: {}) and {} (track {}: {}) have '
                         'different channels. Please make sure all files '
                         'share the same layout.'
                        ).format(self.sources[0], str(j), channels_orig,
                                 self.sources[i], str(j), channels)
                    error.set_text(t)
                    track_mismatch_dialog.run()
        self.update_tracks()

    def update_tracks(self):
        # A new builder instance needs to be created for each entry,
        # therefore put the template on its own to avoid loading a large
        # file every time
        for track in batch_tracks_vbox.get_children():
            batch_tracks_vbox.remove(track)

        # -1 because there is a 'uid' entry
        tracks = self.data[0]
        for i in range(len(tracks) - 1):
            builder = Gtk.Builder()
            builder.add_from_file('/home/alucryd/pyanimenc/track.glade')
            grid = builder.get_object('grid')
            batch_tracks_vbox.pack_start(grid, False, False, 0)
            enable_check = builder.get_object('enable-check')
            enable_check.connect('toggled', handler.on_track_enable_toggled, i)
            codec_entry = builder.get_object('codec-entry')
            name_entry = builder.get_object('name-entry')
            name_entry.connect('changed', handler.on_track_name_changed, i)
            lang_entry = builder.get_object('lang-entry')
            lang_entry.connect('changed', handler.on_track_lang_changed, i)
            encode_check = builder.get_object('encode-check')
            encode_check.connect('toggled', handler.on_track_encode_toggled, i)

            track = tracks['track' + str(i)]
            codec = track['codec']
            name = track.get('name', '')
            lang = track.get('lang', 'und')
            if codec in vtypes:
                type = 'video'
                enable_check.set_label('Video')
                enable_check.set_sensitive(False)
                codec = vtypes[codec]
            elif codec in atypes:
                type = 'audio'
                enable_check.set_label('Audio')
                channels = track['channels']
                if channels == '2':
                    channels = '2.0'
                elif channels == '6':
                    channels = '5.1'
                elif channels == '8':
                    channels = '7.1'
                codec = atypes[codec]
            elif codec in stypes:
                type = 'subtitle'
                enable_check.set_label('Subtitle')
                encode_check.set_sensitive(False)
                codec = stypes[codec]

            self.tracks.append([type, codec, name, lang, True, True, i])
            if type == 'audio':
                codec = codec + ' ' + channels
            if type == 'subtitle':
                # Put this here to avoid out of range index.
                encode_check.set_active(False)
            codec_entry.set_text(codec)
            name_entry.set_text(name)
            lang_entry.set_text(lang)

        window.show()

    def on_track_mismatch_ok_clicked(self, button):
        track_mismatch_dialog.hide()

    def on_batch_start_clicked(self, button):
        if not os.path.isdir('out'):
            os.mkdir(self.folder + '/out')

        for i in range(len(self.sources)):
            vtrack = []
            atracks = []
            stracks = []
            s = self.sources[i]
            uid = self.data[i]['uid']
            for track in self.tracks:
                # [[id, filename, extension, name, language, transcode?]...]
                j = track[6]
                f, e = os.path.splitext(s)
                e = e.strip('.')
                n = track[2]
                l = track[3]
                t = track[5]
                if track[0] == 'video' and track[4]:
                    if track[5]:
                        f = 'out/' + f
                        e = track[1]
                    vtrack = [j, f, e, n, l, t]
                if track[0] == 'audio' and track[4]:
                    if track[5]:
                        f = 'out/' + f
                        e = track[1]
                        f = f + '_' + str(j)
                    atracks.append([j, f, e, n, l, t])
                if track[0] == 'subtitle' and track[4]:
                    stracks.append([j, f, e, n, l, t])

            # Extract tracks
            # Only extract audio tracks that need transcoding.
            tracks = []
            for track in atracks:
                if track[5]:
                    tracks.append(track)

            self.queue.submit(self.extract, s, tracks)

            if vtrack[5]:
                # Create VapourSynth script
                self.queue.submit(self.vpy, s)

                # Encode video
                if self.venc == 'x264' or self.venc == 'x264-10bit':
                    self.queue.submit(self.x264, s, vtrack[1])

            # Encode audio
            for i in range(len(atracks)):
                track = atracks[i]
                if track[5]:
                    a = track[1] + '.' + track[2]
                    if self.aenc == 'fdkaac':
                        self.queue.submit(self.fdkaac, a, track[1])
                    elif self.aenc == 'lame':
                        m = lame_mode_cbtext.get_active_text()
                        b = lame_bitrate_spin.get_value_as_int()
                        q = lame_quality_spin.get_value_as_int()
                        self.queue.submit(self.lame, a, track[1], m, b, q)

            # Merge tracks
            self.queue.submit(self.merge, s, vtrack, atracks, stracks, uid)

            # Clean up
            self.queue.submit(self.clean)

    def extract(self, source, tracks):
        cmd = MatroskaOps(source).extract(tracks)
        print(cmd)
        subprocess.call(cmd, shell=True)
        #with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stdout.readline()
        #        log_buffer.insert(log_buffer.get_end_iter(), line)
        #        if line:
        #            print(line)
        #        else:
        #            break

    def merge(self, source, vtrack, atracks, stracks, uid):
        # These variables cannot be changed earlier because the
        # asynchronous mkvextract process will get the wrong values.
        if vtrack[5]:
            vtrack[0] = 0
            vtrack[2] = 'mp4'
        for i in range(len(atracks)):
            if atracks[i][5]:
                atracks[i][0] = 0
                atracks[i][2] = self.acontainer

        cmd = MatroskaOps(source).merge(vtrack, atracks, stracks, uid)
        print(cmd)
        subprocess.call(cmd, shell=True)
        #with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stdout.readline()
        #        log_buffer.insert(log_buffer.get_end_iter(), line)
        #        if line:
        #            print(line)
        #        else:
        #            break

    def clean(self):
        for f in os.listdir():
            if re.search('\.vpy$', f) or re.search('\.ffindex$', f):
                os.remove(f)
        for f in os.listdir('out/'):
            if not re.search('\.mkv$', f):
                os.remove('out/' + f)

    def vpy(self, source):
        v = ''
        s = ''
        c = ''
        d = ''
        r = ''

        v = 'import vapoursynth as vs\n'
        v = v + 'core = vs.get_core()\n'
        s = 'clip = core.ffms2.Source("{}", fpsnum={}, fpsden={})\n'
        s = s.format(source, self.fpsnum, self.fpsden)
        if self.crop:
            c = 'clip = core.std.CropRel(clip, {}, {}, {}, {})\n'
            c = c.format(self.crop[0], self.crop[1], self.crop[2],
                         self.crop[3])
        if self.deband:
            d = 'clip = core.f3kdb.Deband(clip, preset="{}", '
            d = d + 'output_depth=16)\n'
            d = d.format(self.deband)
        if self.resize:
            r = 'clip = core.resize.{}(clip, {}, {})\n'
            r = r.format(self.resize[2].capitalize(), self.resize[0],
                         self.resize[1])
        v = v + s + c + d + r
        v = v + 'clip.set_output()'

        vpy = re.sub('[^.]*$', 'vpy', source)
        with open(vpy, 'w') as f:
            f.write(v)

    def x264(self, source, dest):
        #cmd = Encode(source).info()
        #with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stdout.readline()
        #        if line:
        #            # Get the frame total
        #            if 'Frames' in line:
        #                dur = line.split(' ')[1]
        #                dur = int(dur)
        #        else:
        #            break

        cmd = Encode(source).x264(self.vquality, self.vcontainer, self.vdepth,
                                  self.vpreset, self.vtune, dest)
        print(cmd)
        subprocess.call(cmd, shell=True)
        #with subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stderr.readline()
        #        log_buffer.insert(log_buffer.get_end_iter(), line)
        #        if line:
        #            # Get the current frame
        #            if re.match('^[0-9]+ ', line):
        #                pos = line.split(' ')[0]
        #                pos = int(pos)
        #                progress = round(pos / dur, 2)
        #                status_pbar.set_fraction(progress)
        #        else:
        #            status_pbar.set_fraction(1)
        #            break

    def fdkaac(self, source, dest):
        cmd = Encode(source).fdkaac(self.aquality, self.acontainer, dest)
        print(cmd)
        subprocess.call(cmd, shell=True)
        #with subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE,
        #                      universal_newlines=True) as proc:
        #    while True:
        #        line = proc.stderr.readline()
        #        log_buffer.insert(log_buffer.get_end_iter(), line)
        #        if line:
        #            # Get the clip duration
        #            if 'Duration' in line:
        #                dur = re.findall('[0-9]{2}:[0-9]{2}:[0-9]{2}', line)[0]
        #                h, m, s = dur.split(':')
        #                dur = int(h) * 3600 + int(m) * 60 + int(s)
        #            # Get the current timestamp
        #            if re.match('[0-9]{2}:[0-9]{2}\.[0-9]{3}', line):
        #                pos = re.findall('^[0-9]{2}:[0-9]{2}', line)[0]
        #                m, s = pos.split(':')
        #                pos = int(m) * 60 + int(s)
        #                progress = round(pos / dur, 2)
        #                status_pbar.set_fraction(progress)
        #        else:
        #            status_pbar.set_fraction(1)
        #            break

    def lame(self, source, dest, mode, bitrate, quality):
        cmd = Encode(source).lame(dest, mode, bitrate, quality)
        print(cmd)
        subprocess.call(cmd, shell=True)

    def on_stop_clicked(self, button):
        self.queue.shutdown()

    def on_batch_vpy_clicked(self, button):
        vpy_dialog.run()

    def on_vpy_crop_toggled(self, check):
        if check.get_active():
            vpy_lcrop_spin.set_sensitive(True)
            vpy_rcrop_spin.set_sensitive(True)
            vpy_tcrop_spin.set_sensitive(True)
            vpy_bcrop_spin.set_sensitive(True)
            self.crop = [vpy_lcrop_spin.get_value_as_int(),
                         vpy_rcrop_spin.get_value_as_int(),
                         vpy_tcrop_spin.get_value_as_int(),
                         vpy_bcrop_spin.get_value_as_int()]
        else:
            self.crop = []
            vpy_lcrop_spin.set_sensitive(False)
            vpy_rcrop_spin.set_sensitive(False)
            vpy_tcrop_spin.set_sensitive(False)
            vpy_bcrop_spin.set_sensitive(False)

    def on_vpy_lcrop_changed(self, spin):
        self.crop[0] = spin.get_value_as_int()

    def on_vpy_rcrop_changed(self, spin):
        self.crop[1] = spin.get_value_as_int()

    def on_vpy_tcrop_changed(self, spin):
        self.crop[2] = spin.get_value_as_int()

    def on_vpy_bcrop_changed(self, spin):
        self.crop[3] = spin.get_value_as_int()

    def on_vpy_resize_toggled(self, check):
        if check.get_active():
            vpy_wresize_spin.set_sensitive(True)
            vpy_hresize_spin.set_sensitive(True)
            vpy_resize_filter_cbtext.set_sensitive(True)
            self.resize = [vpy_wresize_spin.get_value_as_int(),
                           vpy_hresize_spin.get_value_as_int(),
                           vpy_resize_filter_cbtext.get_active_text()]
        else:
            self.resize = []
            vpy_wresize_spin.set_sensitive(False)
            vpy_hresize_spin.set_sensitive(False)
            vpy_resize_filter_cbtext.set_sensitive(False)

    def on_vpy_wresize_changed(self, spin):
        self.resize[0] = spin.get_value_as_int()

    def on_vpy_hresize_changed(self, spin):
        self.resize[1] = spin.get_value_as_int()

    def on_vpy_resize_filter_changed(self, combo):
        self.resize[2] = combo.get_active_text()

    def on_vpy_deband_toggled(self, check):
        if check.get_active():
            vpy_deband_preset_cbtext.set_sensitive(True)
            vpy_deband_channel_cbtext.set_sensitive(True)
            vpy_deband_nograin_check.set_sensitive(True)
            self.deband_preset()
        else:
            self.deband = ''
            vpy_deband_preset_cbtext.set_sensitive(False)
            vpy_deband_channel_cbtext.set_sensitive(False)
            vpy_deband_nograin_check.set_sensitive(False)

    def on_vpy_deband_preset_changed(self, combo):
        self.deband_preset()

    def on_vpy_deband_channel_changed(self, combo):
        self.deband_preset()

    def on_vpy_deband_nograin_toggled(self, check):
        self.deband_preset()

    def deband_preset(self):
        p = vpy_deband_preset_cbtext.get_active_text()
        c = vpy_deband_channel_cbtext.get_active_text()
        n = vpy_deband_nograin_check.get_active()
        self.deband = p
        if c in ['luma', 'chroma']:
            self.deband = '/'.join([self.deband, c])
        if n:
            self.deband = '/'.join([self.deband, 'nograin'])

    def on_vpy_fpsden_changed(self, spin):
        self.fpsden = spin.get_value_as_int()

    def on_vpy_fpsnum_changed(self, spin):
        self.fpsnum = spin.get_value_as_int()

    def on_vpy_ok_clicked(self, button):
        vpy_dialog.hide()

    def on_track_name_changed(self, entry, i):
        self.tracks[i][2] = entry.get_text()

    def on_track_lang_changed(self, entry, i):
        self.tracks[i][3] = entry.get_text()

    def on_track_enable_toggled(self, check, i):
        self.tracks[i][4] = check.get_active()

    def on_track_encode_toggled(self, check, i):
        self.tracks[i][5] = check.get_active()

    def on_venc_changed(self, combo):
        self.venc = combo.get_active_text()
        if self.venc in ['x264', 'x264-10bit']:
            self.vquality = x264_quality_spin.get_value_as_int()
            self.vcontainer = x264_container_cbtext.get_active_text()
            self.vpreset = x264_preset_cbtext.get_active_text()
            self.vtune = x264_tune_cbtext.get_active_text()
        if self.venc == 'x264':
            self.vdepth = 8
        elif self.venc == 'x264-10bit':
            self.vdepth = 10

    def on_aenc_changed(self, combo):
        self.aenc = combo.get_active_text()
        if self.aenc == 'fdkaac':
            self.aquality = fdkaac_quality_spin.get_value_as_int()
            self.acontainer = fdkaac_container_cbtext.get_active_text()

    def on_vsettings_clicked(self, button):
        if self.venc in ['x264', 'x264-10bit']:
            x264_dialog.run()

    def on_asettings_clicked(self, button):
        if self.aenc == 'fdkaac':
            fdkaac_dialog.run()
        elif self.aenc == 'lame':
            lame_dialog.run()

    def on_x264_quality_changed(self, spin):
        self.vquality = spin.get_value_as_int()

    def on_x264_container_changed(self, combo):
        self.vcontainer = combo.get_active_text()

    def on_x264_preset_changed(self, combo):
        self.vpreset = combo.get_active_text()

    def on_x264_tune_changed(self, combo):
        self.vtune = combo.get_active_text()

    def on_x264_ok_clicked(self, button):
        x264_dialog.hide()

    def on_fdkaac_quality_changed(self, spin):
        self.aquality = spin.get_value_as_int()

    def on_fdkaac_container_changed(self, combo):
        self.acontainer = combo.get_active_text()

    def on_fdkaac_ok_clicked(self, button):
        fdkaac_dialog.hide()

    def on_lame_mode_changed(self, combo):
        m = combo.get_active_text()
        if m == 'CBR' or m == 'ABR':
            lame_bitrate_spin.set_sensitive(True)
            lame_quality_spin.set_sensitive(False)
        elif m == 'VBR':
            lame_bitrate_spin.set_sensitive(False)
            lame_quality_spin.set_sensitive(True)

    def on_lame_ok_clicked(self, button):
        lame_dialog.hide()

    def on_log_clear_clicked(self, button):
        log_buffer.set_text('')

    def on_window_delete_event(self, *args):
        Gtk.main_quit(*args)

# Some constants and variables
vencs = ['x264', 'x264-10bit']
vcontainers = ['avi', 'mkv', 'mp4', 'ogm']
vtypes = {'V_MPEG4/ISO/AVC': 'h264'}
aencs = ['fdkaac', 'lame']
acontainers= ['aac', 'ac3', 'dts', 'flac', 'mka', 'mp3', 'mp4', 'thd', 'ogg',
              'wv']
atypes = {'A_AAC': 'aac', 'A_AC3': 'ac3', 'A_DTS': 'dts', 'A_FLAC': 'flac',
          'A_MP3': 'mp3', 'A_TRUEHD': 'thd', 'A_VORBIS': 'ogg',
          'A_WAVPACK4': 'wv'}
stypes = {'S_HDMV/PGS': 'sup', 'S_TEXT/ASS': 'ass', 'S_TEXT/SSA': 'ass',
          'S_TEXT/UTF8': 'srt', 'S_VOBSUB': 'sub'}

# Build the GUI
builder = Gtk.Builder()
builder.add_from_file('/usr/share/pyanimenc/pyanimenc.glade')

window = builder.get_object('window')
venc_cbtext = builder.get_object('venc-cbtext')
aenc_cbtext = builder.get_object('aenc-cbtext')
status_pbar = builder.get_object('status-pbar')
log_buffer = builder.get_object('log-buffer')

batch_venc_cbtext = builder.get_object('batch_venc-cbtext')
batch_aenc_cbtext = builder.get_object('batch_aenc-cbtext')
batch_tracks_vbox = builder.get_object('batch_tracks-vbox')
track_mismatch_dialog = builder.get_object('track_mismatch-dialog')
vpy_dialog = builder.get_object('vpy-dialog')
vpy_crop_check = builder.get_object('vpy_crop-check')
vpy_lcrop_spin = builder.get_object('vpy_lcrop-spin')
vpy_rcrop_spin = builder.get_object('vpy_rcrop-spin')
vpy_tcrop_spin = builder.get_object('vpy_tcrop-spin')
vpy_bcrop_spin = builder.get_object('vpy_bcrop-spin')
vpy_resize_check = builder.get_object('vpy_resize-check')
vpy_wresize_spin = builder.get_object('vpy_wresize-spin')
vpy_hresize_spin = builder.get_object('vpy_hresize-spin')
vpy_resize_filter_cbtext = builder.get_object('vpy_resize_filter-cbtext')
vpy_deband_check = builder.get_object('vpy_deband-check')
vpy_deband_preset_cbtext = builder.get_object('vpy_deband_preset-cbtext')
vpy_deband_channel_cbtext = builder.get_object('vpy_deband_channel-cbtext')
vpy_deband_nograin_check = builder.get_object('vpy_deband_nograin-check')
vpy_fpsnum_spin = builder.get_object('vpy_fpsnum-spin')
vpy_fpsden_spin = builder.get_object('vpy_fpsden-spin')

handler = Handler()
builder.connect_signals(handler)

# Populate the encoder combos
for enc in vencs:
    if os.path.isfile('/usr/bin/' + enc):
        venc_cbtext.append_text(enc)
        batch_venc_cbtext.append_text(enc)
        print('Found ' + enc + '.')
    else:
        vencs.pop(enc)

for enc in aencs:
    if os.path.isfile('/usr/bin/' + enc):
        aenc_cbtext.append_text(enc)
        batch_aenc_cbtext.append_text(enc)
        print('Found ' + enc + '.')
    else:
        aencs.pop(enc)

# Set the default settings
for enc in vencs + aencs:
    if enc == 'x264' or enc == 'x264-10bit':
        x264_dialog = builder.get_object('x264-dialog')
        x264_quality_spin = builder.get_object('x264_quality-spin')
        x264_quality_spin.set_value(15)
        x264_container_cbtext = builder.get_object('x264_container-cbtext')
        x264_container_cbtext.set_active(3)
        x264_preset_cbtext = builder.get_object('x264_preset-cbtext')
        x264_preset_cbtext.set_active(6)
        x264_tune_cbtext = builder.get_object('x264_tune-cbtext')
        x264_tune_cbtext.set_active(1)
    elif enc == 'fdkaac':
        fdkaac_dialog = builder.get_object('fdkaac-dialog')
        fdkaac_quality_spin = builder.get_object('fdkaac_quality-spin')
        fdkaac_quality_spin.set_value(4)
        fdkaac_container_cbtext = builder.get_object('fdkaac_container-cbtext')
        fdkaac_container_cbtext.set_active(0)
    elif enc == 'lame':
        lame_dialog = builder.get_object('lame-dialog')
        lame_mode_cbtext = builder.get_object('lame_mode-cbtext')
        lame_bitrate_spin = builder.get_object('lame_bitrate-spin')
        lame_quality_spin = builder.get_object('lame_quality-spin')

venc_cbtext.set_active(False)
batch_venc_cbtext.set_active(False)
aenc_cbtext.set_active(False)
batch_aenc_cbtext.set_active(False)

window.show_all()

Gtk.main()

# vim: ts=4 sw=4 et:
